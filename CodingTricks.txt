- If we have got just TreeNode* root and it has so many children. How do you build the adjacency list?

```
void buildGraph(Node* root, unordered_map<Node*, vector<Node*>>& graph) {
    if (root == NULL)
        return;

    for (auto vec: root->children) {
        graph[root].push_back(vec);
        graph[vec].push_back(root);
        buildGraph(vec, graph);
    }
    return;
}
```

- Fill the set;

```
return nums.size() > set<int>(nums.begin(), nums.end()).size();

```

- Tree Traversals;

(a) Inorder (Left, Root, Right) : 4 2 5 1 3 
(b) Preorder (Root, Left, Right) : 1 2 4 5 3 
(c) Postorder (Left, Right, Root) : 4 5 2 3 1

- Tokens in C++;

        istringstream ss(data);
        string token;
        while(getline(ss, token, ','))
            tokens.push_back(token);
            
            
- USe cases of Trie;

```
This article introduces the data structure trie. It could be pronounced in two different ways: as "tree" or "try". 
Trie which is also called a digital tree or a prefix tree is a kind of search ordered tree data structure mostly used for the efficient dynamic add/search operations with the strings.
Trie is widely used in real life: autocomplete search, spell checker, T9 predictive text, IP routing (longest prefix matching), some GCC containers.

Against hashmap();
Finding all keys with a common prefix.

Enumerating a dataset of strings in lexicographical order.

Scaling for the large datasets. Once the hash table increases in size, there are a lot of hash collisions and the search time complexity could degrade to \mathcal{O}(N^2 \cdot M)O(N 
2
 ⋅M), where NN is the number of the inserted keys.

Trie could use less space compared to hashmap when storing many keys with the same prefix. In this case, using trie has only \mathcal{O}(M \cdot N)O(M⋅N) time complexity, where MM is the key length, and NN is the number of keys.
```


- Sorting using comparator;
sort(intervals.begin(), intervals.end(), [](vector<int> interval1, vector<int> interval2) { return interval1[0] < interval2[0]; });


- Requirements for coding;
#include <iostream>
using namespace std;


- Definition of Binary Tree;

 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };


- Priority Queue in C++ for pairs;

// By default a max heap is created ordered
// by first element of pair.
priority_queue<pair<int, int> > pq;

typedef pair<int, int> pi;
// By default a min heap is created ordered
// by first element of pair.
priority_queue<pi, vector<pi>, greater<pi> > pq;


priority_queue<pair<int, int>, vector<pair<int, int>>, comparator> pq;
struct comparator {
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) {
        if (a.first == b.first)
            return a.second > b.second;
        return a.first < b.first;
    }
};

- Make pair;
make_pair (10,20);


- Sort with lambda function
sort(T.begin(), T.end(), [&](char a, char b) { return vec[a - 'a'] < vec[b - 'a']; });


- If any substring is required after a particular character, then?
path.substr(path.find_last_of('/') + 1)


------ Always remember to find the shortest path via BFS, remember to make a use of visited boolesn.


Which approach to choose, BFS or DFS?

The problem is to return a list of last elements from all levels, so it's the way more natural to implement BFS here.

Time complexity is the same \mathcal{O}(N)O(N) both for DFS and BFS since one has to visit all nodes.

Space complexity is \mathcal{O}(H)O(H) for DFS and
\mathcal{O}(D)O(D) for BFS, where HH is a tree height, and DD is a tree diameter. They both result in \mathcal{O}(N)O(N) space in the worst-case scenarios: skewed tree for DFS and complete tree for BFS.





// In order to insert elements into vector from beginning;
result.insert(result.begin(), pq.top().first);
